 /**
 * JavaCC file
 */options{  JDK_VERSION = "1.5";  MULTI = true;  STATIC = true;}PARSER_BEGIN(Ice9Parser)package parser;import type.*;import table.*;import java.util.*;import java.io.*;public class Ice9Parser{  public static boolean isDebug = false;  public static boolean isDebug2 = false;  public static boolean debugTable = false;  public static SymbolTable globalTable = new SymbolTable();  public static SymbolTable currentTable = new SymbolTable();  public static Stack < String > loopStack = new Stack < String > ();  public static void debug(String text)  {    if (isDebug)    {      System.out.println(text);    }  }  public static void debugTable(String text)  {    if (debugTable)    {      System.out.println(text);    }  }  public static void debug2(String text)  {    if (isDebug2)    {      System.out.println(text);    }  }  public static void debug()  {    System.out.println();  }  public static void main(String args []) throws ParseException, java.io.IOException  {    Ice9Parser parser = null;    try    {      parser = new Ice9Parser(new java.io.FileInputStream("test-suite/tests/test245.9"));      //      parser = new Ice9Parser(new java.io.FileInputStream("test.dat"));      //      parser = new Ice9Parser(System.in);      //      System.out.println("Reading from file " + "dice/test1.9");
      SimpleNode n = parser.program();      //      n.dump("");      System.out.println("successfully");    }    //    catch (java.io.FileNotFoundException e)    //    {    //      System.out.println("Ice9 Parser:  File not found.");    //      return;    //    }    catch (TokenMgrError e)    {      //      System.out.println(e.getMessage());
      String message = e.getMessage();      int lineIndex = message.indexOf("line");      int commaIndex = message.indexOf(",");      int quoteIndex = message.indexOf("\"");      int lineNbr = Integer.parseInt(message.substring(lineIndex + 5, commaIndex));      String t = message.substring(quoteIndex + 1, message.length() - 1);      System.out.println("line " + lineNbr + ": illegal character (" + t + ")");    }    catch (TypeException e)    {      System.out.println(e.prettyMessage());      System.out.println(e.getMessage());      //      System.out.println(e.getMessage());
    }    catch (SymbolTableException e)    {      System.out.println(e.prettyMessage());      System.out.println(e.getMessage());    }    catch (ParseException e)    {      Token t = e.currentToken;      int line = t.next.beginLine;      String value = t.image;      if (value == null)      {        value = "";      }      System.out.println("line " + line + ": syntax error near " + value);      System.out.println(e.getMessage());    }    catch (Exception e)    {      e.printStackTrace();    }    catch (Error e)    {      e.printStackTrace();    }    finally    {      debugTable("debug table: " + currentTable.toString());    }    FileWriter fstream = new FileWriter("test.out");    BufferedWriter out = new BufferedWriter(fstream);    for (int i = 1; i <= 256; i++)    {      try      {        System.out.println("parsing " + "test-suite/tests/test" + i + ".9");        parser.ReInit(new java.io.FileInputStream("test-suite/tests/test" + i + ".9"));        parser.program();        System.out.println("successfully");        out.write("test " + i + " successful!\n");      }      catch (TokenMgrError e)      {        //      System.out.println(e.getMessage());
        String message = e.getMessage();        int lineIndex = message.indexOf("line");        int commaIndex = message.indexOf(",");        int quoteIndex = message.indexOf("\"");        int lineNbr = Integer.parseInt(message.substring(lineIndex + 5, commaIndex));        String t = message.substring(quoteIndex + 1, message.length() - 1);        System.out.println("line " + lineNbr + ": illegal character (" + t + ")");      }      catch (TypeException e)      {        System.out.println(e.prettyMessage());        System.out.println(e.getMessage());        //      System.out.println(e.getMessage());
      }      catch (SymbolTableException e)      {        System.out.println(e.prettyMessage());        System.out.println(e.getMessage());      }      catch (ParseException e)      {        Token t = e.currentToken;        int line = t.next.beginLine;        String value = t.image;        if (value == null)        {          value = "";        }        System.out.println("line " + line + ": syntax error near " + value);        System.out.println(e.getMessage());      }      catch (Exception e)      {        e.printStackTrace();      }      catch (Error e)      {        e.printStackTrace();      }    }    try    {      out.close();    }    catch (Exception e)    {}  }}PARSER_END(Ice9Parser)SKIP :{  " "| "\r"| "\t"| "\n"| "\r\n"}SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}TOKEN :{  < VAR : "var" >| < PROC : "proc" >| < END : "end" >| < RETURN : "return" >| < READ : "read" >| < WRITE : "write" >| < WRITES : "writes" >| < FORWARD : "forward" >| < TYPE : "type" >| < RARROW : "->" >}TOKEN : /*if*/{  < IF : "if" >| < ELSE : "else" >| < FI : "fi" >| < LR : "[]" >}TOKEN : /*do*/{  < DO : "do" >| < OD : "od" >}TOKEN : /*fa*/{  < FA : "fa" >| < AF : "af" >| < TO : "to" >}TOKEN : /*stm*/{  < BREAK : "break" >| < EXIT : "exit" >}TOKEN :{  < TRUE : "true" >| < FALSE : "false" >}/*
id	-> [A-Za-z][A-Za-z0-9_]*
int	-> [0-9]+
string  -> "[^"\n]*" 		# double-quoted string: any char but " and \n
	-> '[^'\n]*'            # single-quoted string: any char but ' and \n
*/TOKEN : /* Three complex tokens */{  < ID :    < LETTER >    (      < LETTER >    | < UNDERSCORE >    | < DIGIT >    )* >| < INT : (< DIGIT >)+ >| < STRING :    "\"" (~[ "\"", "\n" ])* "\""  | "'" (~[ "'", "\n" ])* "'" >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MOD : "%" >| < EQUAL : "=" >| < NOTEQUAL : "!=" >| < GREATERTHAN : ">" >| < LESSTHAN : "<" >| < NOTLESSTHAN : ">=" >| < NOTGREATERTHAN : "<=" >}TOKEN :{  < COLON : ":" >| < ASSIGN : ":=" >| < COMMA : "," >| < LBRACE : "[" >| < RBRACE : "]" >| < LPAREN : "(" >| < RPAREN : ")" >| < QUESTION : "?" >| < SEMICOLON : ";" >}/*
program	-> {var|type|forward|proc} stms
*/SimpleNode program() :{  globalTable = new SymbolTable();  globalTable.parent = SymbolTable.buildInTable();  currentTable = globalTable;  Token end;}{  (    var()  | type()  | forward()  | proc()  )*  stms()  { //System.out.println("successfully!");
  }  end = < EOF >  {    List < String > forwardWOProcs = currentTable.getForwardsWithoutProc();    if (forwardWOProcs.size() > 0)    {      throw new TypeException(TypeError.FORWARD_WITHOUT_PROC, "These forward: " + forwardWOProcs + " has not proc definition.", end);    }    return jjtThis;  }}void tokenTest() :{  Token t;}{  t = < STRING >  {    debug("parsing string: " + t.image);  }  < EOF >}String typeid() :{  debug("in type id");  Token id;}{  id = < ID >  {    TypeRecord type = currentTable.lookupType(id, id.image);    jjtThis.jjtSetValue(type);    return id.image;  }}String op() :{  debug("in op");  Token t;}{  (    t = < PLUS >  | t = < MINUS >  | t = < MULTIPLY >  | t = < DIVIDE >  | t = < MOD >  )  {    return t.image;  }}/*idlist  -> id { ',' id}*/List < Token > idlist() :{  debug("in IdList");  List < Token > tokens = new ArrayList < Token > ();  Token current;}{  current = < ID >  {    tokens.add(current);  }  (    < COMMA > current = < ID >    {      tokens.add(current);    }  )*  {    return tokens;  }}/*
stms	-> stm { stm }		# there is at least one stm

stm	-> if | do | fa | 'break' ';' | 'exit' ';'
	-> 'return' ';'
	-> 'write' exp ';' | 'writes' exp ';'
	-> exp ';'		# any exp is valid
	-> ';'			# the "empty" statement
*/void stms() :{}{  (    stm()  )+}void stm() :{}{  otherstm()| ifstm()}void otherstm() :{  debug("in other");  TypeRecord returnType;}{  dostm()| fa()| break_stm()| exit_stm()| return_stm()| write_stm()| exp() < SEMICOLON > // any exp is valid
| < SEMICOLON > // the "empty" statement
}TypeRecord return_stm() :{  Token t;}{  t = < RETURN > < SEMICOLON >  {    jjtThis.jjtSetValue(TypeRecord.voidType);    return TypeRecord.voidType;  }}TypeRecord exit_stm() :{  Token t;}{  t = < EXIT > < SEMICOLON >  {    jjtThis.jjtSetValue(TypeRecord.voidType);    return TypeRecord.voidType;  }}TypeRecord break_stm() :{  Token t;}{  t = < BREAK >  {    if (loopStack.empty())    {      throw new TypeException(TypeError.WRONG_USAGE, "break is not allowed in the scopes without loop", t);    }  }  < SEMICOLON >  {    jjtThis.jjtSetValue(TypeRecord.voidType);    return TypeRecord.voidType;  }}void write_stm() :{  TypeRecord returnType;  Token write;}{  (    write = < WRITE >  | write = < WRITES >  )  returnType = noAssignExp()  {    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", write);    }    if (returnType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "bool type not allowed", write);    }  }  < SEMICOLON >}/*
if	-> 'if' exp '->' stms { '[]' exp '->' stms } 'fi'
	-> 'if' exp '->' stms { '[]' exp '->' stms } '[]' 'else' '->' stms 'fi'
*/void ifstm() :{  debug("if()");  TypeRecord conditionType;  Token iftoken;  SymbolTable newScope;}{  iftoken = < IF > conditionType = noAssignExp()  {    debug2("type:" + conditionType);    if (!conditionType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "if condition must be bool", iftoken);    }  }  < RARROW >  {    newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;  }  stms()  {    currentTable = currentTable.parent;  }  (    LOOKAHEAD(2)    < LR > conditionType = noAssignExp()    {      if (!conditionType.equals(TypeRecord.boolType))      {        throw new TypeException(TypeError.WRONG_TYPE, "if condition must be bool", iftoken);      }    }    < RARROW >    {      newScope = new SymbolTable();      newScope.parent = currentTable;      currentTable = newScope;    }    stms()    {      currentTable = currentTable.parent;    }  )*  [    LOOKAHEAD(2)    < LR > < ELSE > < RARROW >    {      newScope = new SymbolTable();      newScope.parent = currentTable;      currentTable = newScope;    }    stms()    {      currentTable = currentTable.parent;    }  ]  < FI >}/*
do	-> 'do' exp '->' stms 'od'
*/void dostm() :{  debug("do()");  TypeRecord conditionType;  Token dotoken;}{  dotoken = < DO > conditionType = noAssignExp()  {    if (!conditionType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "do condition must be bool", dotoken);    }  }  < RARROW >  {    SymbolTable newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;    loopStack.push("do");  }  stms()  {    loopStack.pop();    currentTable = currentTable.parent;  }  < OD >}/*
fa	-> 'fa' id ':=' exp 'to' exp '->' stms 'af'
*/void fa() :{  debug("fa()");  TypeRecord lowType;  TypeRecord highType;  Token dotoken;  Token id;}{  < FA > id = < ID > < ASSIGN > lowType = noAssignExp()  {    if (!lowType.equals(TypeRecord.intType))    {      throw new TypeException(TypeError.WRONG_TYPE, "low condition must be int", id);    }  }  < TO > highType = noAssignExp()  {    if (!highType.equals(TypeRecord.intType))    {      throw new TypeException(TypeError.WRONG_TYPE, "high condition must be int", id);    }  }  < RARROW >  {    SymbolTable newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;    currentTable.insertId(id, new TypeRecord(BasicType.INT, true));    loopStack.push("fa");  }  stms()  {    loopStack.pop();    currentTable = currentTable.parent;  }  < AF >}/*
proc	-> 'proc' id '(' declist ')'
		{type|var} {stm} 'end'
	-> 'proc' id '(' declist ')' ':' typeid 
		{type|var} {stm} 'end'
*/void proc() :{  debug("proc()");  Token id;  List < ParaType > paras;  TypeRecord returnType = null;  ProcType forwardType = null;  Token end;}{  < PROC > id = < ID >  {    if (currentTable.existsProc(id))    {      throw new SymbolTableException(LookupError.PROC_ALREADY_DEFINED, id, "proc has been defined in current table.");    }    if (currentTable.existsForward(id))    {      forwardType = currentTable.lookupForward(id);    }  }  < LPAREN > paras = declist() < RPAREN >  [    < COLON > typeid()    {      returnType = (TypeRecord) ((SimpleNode) (jjtree.peekNode())).jjtGetValue();    }  ]  {    if (forwardType != null)    {      if (returnType == null)      {        returnType = TypeRecord.voidType;      }      if (!returnType.equals(forwardType.returnType))      {        throw new TypeException(TypeError.WRONG_TYPE, "proc " + id.image + " return type of proc is different from forward", id);      }      List < ParaType > forwardParas = forwardType.paraTypes;      if (paras.size() != forwardParas.size())      {        throw new TypeException(TypeError.WRONG_TYPE, "proc " + id.image + " size of parameters of proc is different from forward", id);      }      for (int i = 0; i < paras.size(); i++)      {        if (!paras.get(i).type.equals(forwardParas.get(i).type))        {          throw new TypeException(TypeError.WRONG_TYPE, "proc " + id.image + " " + i + "th para is different from forward", id);        }      }    }    ProcType newproc = new ProcType(returnType, paras);    currentTable.insertProc(id, newproc);    jjtThis.jjtSetValue(TypeRecord.voidType);    SymbolTable newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;    if (returnType != null)    {      currentTable.insertId(id, returnType);    }    for (ParaType para : paras)    {      currentTable.insertId(para.id, para.type);    }  }  (    type()  | var()  )*  (    stm()  )*  {    currentTable = currentTable.parent;  }  end = < END >}/*var	-> 'var' varlist
varlist  -> idlist ':' typeid { '[' int ']' } { ',' varlist}*/void varlist() :{  debug("varlist()");  List < Token > tokens;  TypeRecord type;  Token size;  String typeid;  TypeRecord currentType;  SimpleNode typeNode;  boolean isFirst = true;  TypeRecord baseType;  TypeRecord returnType;}{  tokens = idlist() < COLON > typeid = typeid()  {    typeNode = (SimpleNode) jjtree.peekNode();    currentType = (TypeRecord) typeNode.jjtGetValue();    baseType = currentType;    returnType = currentType;  }  (    < LBRACE > size = < INT > < RBRACE >    {      if (Integer.parseInt(size.image) == 0)      {        throw new TypeException(TypeError.WRONG_VALUE, "array size cannot be 0", size);      }      int intsize = Integer.parseInt(size.image);      if (isFirst)      {        currentType = TypeRecord.arrayType(intsize, currentType);        isFirst = false;        returnType = currentType;      }      else      {        TypeRecord newArray = TypeRecord.arrayType(intsize, baseType);        currentType.underType = newArray;        currentType = newArray;      }    }  )*  {    currentTable.insertIds(tokens, returnType);  }  (    LOOKAHEAD(2)    < COMMA > varlist()  )*}void var() :{  debug("var()");}{  < VAR > varlist()}/*
forward -> 'forward' id '(' declist ')'
	-> 'forward' id '(' declist ')' ':' typeid
declist	-> idlist ':' typeid { ',' declist }
	->			# empty
*/List < ParaType > declist() :{  debug("declist()");  List < Token > ids = new ArrayList < Token > ();  List < ParaType > paraTypes = new ArrayList < ParaType > ();  SimpleNode typeNode;  TypeRecord type;  List < ParaType > newList;  HashSet < String > paraNames = new HashSet < String > ();}{  (    ids = idlist() < COLON > typeid()    {      typeNode = (SimpleNode) jjtree.peekNode();      type = (TypeRecord) typeNode.jjtGetValue();      for (Token id : ids)      {        if (paraNames.contains(id.image))        {          throw new TypeException(TypeError.PARA_NAME_ALREADY_DEFINED, "parameter name in proc declaration cannot be same", id);        }        paraNames.add(id.image);        paraTypes.add(new ParaType(type, id));      }    }    (      LOOKAHEAD(2)      < COMMA > newList = declist()      {        for (ParaType paratype : newList)        {          paraTypes.add(paratype);        }      }    )*  |    {}  )  {    return paraTypes;  }}void forward() :{  debug("forward()");  Token id;  List < ParaType > paras = null;  TypeRecord returnType = null;}{  < FORWARD > id = < ID > < LPAREN > paras = declist() < RPAREN >  [    ":" typeid()    {      returnType = (TypeRecord) ((SimpleNode) (jjtree.peekNode())).jjtGetValue();    }  ]  {    if (returnType == null)    {      returnType = TypeRecord.voidType;    }    ProcType newforward = new ProcType(returnType, paras);    currentTable.insertForward(id, newforward);  }}/* type	-> 'type' id '=' typeid { '[' int ']' } */void type() :{  debug("type()");  Token id;  String typeId;  TypeRecord baseType;  Token size;  TypeRecord returnType;  TypeRecord currentType;  boolean isFirst = true;}{  < TYPE > id = < ID > < EQUAL > typeId = typeid()  {    baseType = (TypeRecord) (((SimpleNode) (jjtree.peekNode())).jjtGetValue());    currentType = baseType;    returnType = currentType;  }  (    < LBRACE > size = < INT > < RBRACE >    {      int intsize = Integer.parseInt(size.image);      if (intsize == 0)      {        throw new TypeException(TypeError.WRONG_VALUE, "array size cannot be 0", size);      }      if (isFirst)      {        currentType = TypeRecord.arrayType(intsize, baseType);        returnType = currentType;        isFirst = false;      }      else      {        TypeRecord newArray = TypeRecord.arrayType(intsize, baseType);        currentType.underType = newArray;        currentType = newArray;      }    }  )*  {    currentTable.insertType(id, returnType);    jjtThis.jjtSetValue(returnType);  }}/*
lvalue	-> id | lvalue '[' exp ']'
*/TypeRecord lvalue() :{  debug("lvalue()");  Token id;  TypeRecord type;  Token lbrace;  TypeRecord indexType;}{  id = < ID >  {    type = currentTable.lookupId(id);  }  (    lbrace = < LBRACE > indexType = noAssignExp() < RBRACE >    {      if (!TypeRecord.isArray(type))      {        throw new TypeException(TypeError.WRONG_TYPE, "type must be array for indexing", lbrace);      }      if (!indexType.equals(TypeRecord.intType))      {        throw new TypeException(TypeError.WRONG_TYPE, "array index must be integer", lbrace);      }      type = type.underType;    }  )*  {    debugTable("id:" + id + " type: " + type);    jjtThis.jjtSetValue(type);    return type;  }}/*
exp	-> lvalue
	-> lvalue ':=' exp
	-> int				# integer literal
	-> 'true'			# boolean literal
	-> 'false'			# boolean literal
	-> string
	-> 'read'
	-> '-' exp
	-> '?' exp
	-> id '(' ')'			# procedure call
	-> id '(' exp { ',' exp } ')'	# procedure call
	-> exp '+' exp
	-> exp '-' exp
	-> exp '*' exp
	-> exp '/' exp
	-> exp '%' exp
	-> exp '=' exp
	-> exp '!=' exp
	-> exp '>' exp
	-> exp '<' exp
	-> exp '>=' exp
	-> exp '<=' exp
	-> '(' exp ')'
*/Token compareOp() :{  Token t;}{  (    t = < EQUAL >  | t = < NOTEQUAL >  | t = < GREATERTHAN >  | t = < LESSTHAN >  | t = < NOTGREATERTHAN >  | t = < NOTLESSTHAN >  )  {    return t;  }}void Additive() :{  Object returnType;  Token t;}{  Times()  {    returnType = ((SimpleNode) (jjtree.peekNode())).jjtGetValue();  }  (    LOOKAHEAD(2)    (      t = < PLUS >    | t = < MINUS >    | t = < MOD >    )    Times() #plusMinus(2)  {    SimpleNode timesNode = (SimpleNode) jjtree.peekNode();    SimpleNode firstChild = ((SimpleNode) (timesNode.jjtGetChild(0)));    SimpleNode secondChild = ((SimpleNode) (timesNode.jjtGetChild(1)));    TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();    TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();    if (firstType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if (!firstType.equals(secondType))    {      throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in times", t);    }    if (firstType.equals(TypeRecord.boolType) && (t.image.equals("-") || t.image.equals("%")))    {      throw new TypeException(TypeError.WRONG_TYPE, "cannot use -/% for two bools", t);    }    returnType = firstType;    timesNode.jjtSetValue(returnType);  })*{  jjtThis.jjtSetValue(returnType);  debug2("in additive: ");  debug2("this: " + jjtThis.jjtGetValue());}}void Times() :{  Object returnType;  Token t;}{  PrefixExp()  {    returnType = ((SimpleNode) (jjtree.peekNode())).jjtGetValue();  }  (    LOOKAHEAD(2)    (      t = < MULTIPLY >    | t = < DIVIDE >    )    PrefixExp() #timeDivide(2)  {    SimpleNode timesNode = (SimpleNode) jjtree.peekNode();    SimpleNode firstChild = ((SimpleNode) (timesNode.jjtGetChild(0)));    SimpleNode secondChild = ((SimpleNode) (timesNode.jjtGetChild(1)));    TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();    TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();    if (firstType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if (!firstType.equals(secondType))    {      throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in times", t);    }    if (firstType.equals(TypeRecord.boolType) && t.image.equals("/"))    {      throw new TypeException(TypeError.WRONG_TYPE, "cannot use / for two bools", t);    }    returnType = firstType;    timesNode.jjtSetValue(returnType);  })*{  jjtThis.jjtSetValue(returnType);  debug2("in times: ");  debug2("this: " + jjtThis.jjtGetValue());}}TypeRecord PrefixExp() :{  TypeRecord returnType;}{  (    returnType = Unary()  | returnType = PrimaryExp()  )  {    jjtThis.jjtSetValue(returnType);    return returnType;  }}TypeRecord Unary() :{  Object returnType;  Token t = null;  Token t2 = null;}{  (    t = < MINUS > [ t2 = < QUESTION > ] returnType = PrimaryExp()  | t = < QUESTION > [ t2 = < MINUS > ] returnType = PrimaryExp()  )  {    if (returnType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if ((t.image.equals("?") || (t2 != null && t2.image.equals("?"))) && !returnType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "unary ? only allows bool", t);    }    if (t.image.equals("-") && (!returnType.equals(TypeRecord.boolType) && !returnType.equals(TypeRecord.intType)))    {      throw new TypeException(TypeError.WRONG_TYPE, "unary - only allows bool and int", t);    }    if ((t.image.equals("?") || (t2 != null && t2.image.equals("?"))) && returnType.equals(TypeRecord.boolType))    {      returnType = TypeRecord.intType;    }    jjtThis.jjtSetValue(returnType);    debug2("in unary: ");    debug2("this: " + jjtThis.jjtGetValue());    return (TypeRecord) returnType;  }}TypeRecord PrimaryExp() :{  TypeRecord returnType;  SimpleNode child;}{  (    < INT >    {      jjtThis.jjtSetValue(TypeRecord.intType);      debug2("found int types");      debug2("this: " + jjtThis.jjtGetValue());      returnType = TypeRecord.intType;    }  | < TRUE >    {      jjtThis.jjtSetValue(TypeRecord.boolType);      returnType = TypeRecord.boolType;    }  | < FALSE >    {      jjtThis.jjtSetValue(TypeRecord.boolType);      returnType = TypeRecord.boolType;    }  | < STRING >    {      jjtThis.jjtSetValue(TypeRecord.strType);      returnType = TypeRecord.strType;    }  | < READ >    {      jjtThis.jjtSetValue(TypeRecord.intType);      returnType = TypeRecord.intType;    }  | < LPAREN > returnType = noAssignExp() < RPAREN >    {      jjtThis.jjtSetValue(returnType);    }  | LOOKAHEAD(procedureCall())    returnType = procedureCall()    {      jjtThis.jjtSetValue(returnType);    }  | returnType = lvalue()    {      jjtThis.jjtSetValue(returnType);    }  )  {    return returnType;  }}TypeRecord procedureCall() :{  Token id;  ProcType proc;  List < TypeRecord > types = new ArrayList < TypeRecord > ();  TypeRecord paraType;  Token rparen;}{  id = < ID >  {    proc = currentTable.lookupProc(id);  }  < LPAREN >  [    paraType = noAssignExp()    {      types.add(paraType);    }    (      < COMMA > paraType = noAssignExp()      {        types.add(paraType);      }    )*  ]  rparen = < RPAREN >  {    if (types.size() != proc.paraTypes.size())    {      throw new TypeException(TypeError.WRONG_TYPE, "the size of parameters " + types.size() + " is not equal to the size of proc " + id.image + " parameters: " + proc.paraTypes.size(), rparen);    }    for (int i = 0; i < types.size(); i++)    {      TypeRecord procparaType = proc.paraTypes.get(i).type;      if (!types.get(i).equals(procparaType))      {        throw new TypeException(TypeError.WRONG_TYPE, i + "th parameter " + types.get(i) + " is not equal to " + i + "th parameter" + procparaType + " of proc " + id.image, rparen);      }    }    jjtThis.jjtSetValue(proc.returnType);    return proc.returnType;  }}void associateExp() :{}{  Additive()  {    SimpleNode node = (SimpleNode) (jjtThis.jjtGetChild(0));    jjtThis.jjtSetValue(node.jjtGetValue());  }}void exp() :{  debug("exp()");  Token assign;}{  (    LOOKAHEAD(lvalue() < ASSIGN > noAssignExp())    lvalue() assign = < ASSIGN > noAssignExp()    {      SimpleNode node = (SimpleNode) (jjtThis);      debug2("node in assign: " + node);      SimpleNode firstChild = ((SimpleNode) (node.jjtGetChild(0)));      SimpleNode secondChild = ((SimpleNode) (node.jjtGetChild(1)));      TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();      TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();      if (!firstType.equals(secondType))      {        throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in assign", assign);      }      if (TypeRecord.isArray(firstType))      {        throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", assign);      }      if (firstType.notAssignable)      {        throw new TypeException(TypeError.WRONG_TYPE, "this lvalue is not assignable", assign);      }      jjtThis.jjtSetValue(TypeRecord.voidType);    }  | noAssignExp()    {      SimpleNode node = (SimpleNode) (jjtThis.jjtGetChild(0));      jjtThis.jjtSetValue(node.jjtGetValue());    }  )}TypeRecord noAssignExp() :{  Object returnType;  Token t;}{  associateExp()  {    returnType = ((SimpleNode) (jjtree.peekNode())).jjtGetValue();  }  [    t = compareOp() associateExp() #compares(3)  {    SimpleNode timesNode = (SimpleNode) jjtree.peekNode();    debug2("in noassign: ");    debug2("timesNode: " + timesNode);    debug2("timesNode: " + timesNode.jjtGetValue());    //      System.out.println("timesNode: " + );    SimpleNode firstChild = ((SimpleNode) (timesNode.jjtGetChild(0)));    SimpleNode secondChild = ((SimpleNode) (timesNode.jjtGetChild(2)));    TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();    TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();    if (firstType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if (!firstType.equals(secondType))    {      throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in times", t);    }    if (firstType.equals(TypeRecord.boolType) && (!t.image.equals("=") && !t.image.equals("!=")))    {      throw new TypeException(TypeError.WRONG_TYPE, "cannot use >/</>=/<= for two bools", t);    }    returnType = TypeRecord.boolType;  }]{  jjtThis.jjtSetValue(returnType);  return (TypeRecord) returnType;}}
\documentclass[times, 10pt,onecolumn]{article} 
\usepackage{latex8}
\usepackage{times}
\usepackage{url}
%\usepackage{amsfonts, amsthm}

\title{Project Proposal}
\author{
Xusheng Xiao\\
\small{xxiao2@ncsu.edu}\\
\and
Xi Ge\\
\small{xge@ncsu.edu}\\
\and
Da Young Lee\\
\small{dlee10@ncsu.edu}
}
\date{January 27, 2010}


\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}

\begin{document}
\maketitle

\begin{flushleft}
\textbf{Project Topic:}\end{flushleft} Symbolic Execution in Software Engineering.\\

\begin{flushleft}
\textbf{Goal:}\end{flushleft}
Symbolic execution~\cite{symbolic} is a form of program analysis that uses symbolic values instead of concrete values as inputs and symbolic expressions to represent the values of program variables. As a result, the outputs computed by a program are expressed as an expression of the symbolic inputs. This technique is widely used in automatic test data and test case generation in software engineering. In this project, we will provide a study of how finite state automaton, context-free grammer are used in assisting symbolic execution to generate test data and test cases more effectively. We also provide a study about the techniques that are used to alleviate the path explosion problem and optimize the performance of symbolic execution. 
\\

\begin{flushleft}
\textbf{Project Description}:\end{flushleft}
Instead of feeding normal input to programs, the symbolic execution proceeds with symbolic representing values\cite{symbolic}. In this project, we intend to explore the application of computation theory in this field and provide a detailed survey of the existing tools and techniques associating with symbolic execution in software engineering. 

\begin{enumerate}
\item{\textbf{Finite State Automaton: Regular Expression Operation.} Dynamic symbolic execution (DSE) is a variation of static symbolic execution. DSE performs a symbolic execution of the program by assigning symbolic variables to each program input and executes the program starting with arbitrary inputs. During the execution, DSE collects symbolic constraints on inputs obtained from predicates in branch statements along the execution. Then a constraint solver is used to compute new inputs in order to execute the program along different execution paths. Existing dynamic symbolic execution (DSE)~\cite{dart,exe,cute} techniques can effectively generate test inputs for various programs to achieve high coverage. However, when dealing with the programs that use regular expression operations, the logic complexity makes it much more difficult for the DSE engine to achieve high branch coverage of the program under test within limited time and resources. With the help of finite state automaton, DSE is guided to achieve satisfactory branch coverage rate~\cite{reggae}.}

\item{\textbf{Context-Free Grammar: Structured Inputs Generation.} Symbolic execution for programs can be effectively reduced to a constraint-generation phase followed by a constraint-solving phase. Symbolic execution has trouble creating test cases that achieve high coverage for programs that expect structured inputs, such as those that require input strings from a context-free grammar. Kiezun et al.~\cite{hampi} propose Hampi to create grammar-based input constraints and then fed those into symbolic execution engine to generate test cases for programs. Given a set of constraints over a string variable, Hampi constraints express membership in regular and fixed-size context-free languages and output a string that satisfies all the constraints. Their evaluation results show that using Hampi can improve the effectiveness of symbolic execution. We plan to discuss the details in our project.}

\item{\textbf{Computability and Computation Complexity: Exploration Of Program.} Dynamic symbolic execution (DSE)~\cite{dart,exe,cute}, is adopted by automatic test case generation tool to explore the feasible paths of the program under test for achieving high coverage. In theory, all feasible execution paths will be exercised eventually through the iterations of constraint collection and constraint solving in DSE. A program under test can be modeled as a control flow graph (CFG)~\cite{testbook}, whose nodes represent simple primitive statements (such as input, output, and assignment) and edges represent the flow of control. An execution path of the program is a path on CFG from the starting node, entry of the program, to the exit node, exit of the program. Thus, to explore all paths of the program under test, i.e. achieving 100\% path coverage, is to enumerate all paths between two nodes in a graph, which is well known as a NP-hard problem~\cite{graph}. To alleviate this path explosion problem and to reduce the computation complexity, different techniques has been proposed, such as performing symbolic execution compositionally~\cite{compositional}, selective symbolic execution~\cite{selective} and fitness-guided path exploration~\cite{fitness}. In our project, we plan to discuss these techniques and provide example issues that can be solved using these techniques. Additionally, we plan to discuss the existing issues that are still not solved in the area of symbolic execution.}
\end{enumerate}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
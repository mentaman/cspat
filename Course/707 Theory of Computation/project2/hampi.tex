\section{hampi}
A lot of automatic analysis, testing, and verification tools can be reduced to a constraint generation phase and a constraint solving phase. The seperation of these two phases have leveraged more reliable and maintainable tools. In addition to that, increasing availability and efficiency of many off-the-shelf constraint solver makes the approach even more compelling. Hampi \cite{hampi} is designed and implemented as a constraint solver for string-manipulating programs. Hampi constraints express membership in regualar language, fixed size context-free language and membership predicates. Given a set of constraints, hampi will give the string that satisfies all the constraints or report unsatisfiable. The experiment showes that Hampi is efficient in finding SQL injections by static and dynamic ananlysis on web applications and powerful in automated bug finding in system testing of c programs.
 
Many programs, like web applications, take string as inputs, manipulate them and then use them in sensitive operations as database queries. String constraint solver plays a very important role in automatic testing\cite{}, verifying the correctness of program outputs\cite{}, and finding security faults\cite{}. Writing a string constraints solver is a very time-consuming work, and integrating it will cause less maintainable system. Therefore, Hampi is designed and implemented to meet this need as a third-party module that can be easily integrated into a variety of applications.     

Hampi constraints express membership by regular language, fixed size context-free language. It may contain a fixed size string variable, context-free language definition, regular language definition and operations, and language-membership predicates. Given a set of string constraints over a string variable, Hampi outputs a string that satisfies all the constraints or reports that the constraints are unsatisfiable. Hampi is used as a component in testing, analysis, and verification applcations. Hampi can also be used to solve the intersection, containment, and equivalence problems for regular and fixed size context free languages.

A key feature for Hampi is that the fixed-sizing of regular and context free grammar. This feature differentiate Hampi with other string constraints solvers that used in many testing and analysis applications. Fixed-sizing is not a handicap for a constraint solver, but allows more expressive languages and many operations upon context-free language that would be undecidable without fixed-sizing. Fixed-sizing also renders the satisfiability problem solved by Hampi more tractable.

Hampi works in four steps: the first is to normalize the input constraints to formal forms which are called core string constraints. The core string constraints are expressions of the form $v\in R$ or $v\notin R$, where $v$ is the input fixed-size string varible, and $R$ is the regular expression. Second, translate the core string constraints into quantifier-free logic of bit-vectors which are fixed-size, ordered lists of bits. Third, hand over the bit-vector constraints logic that Hampi uses to STP\cite{} which is a constraints solver for bit-vectors and arrays. Fourth, according to the report provided by STP, we get the result whether the original string constraints is satisfiable, if yes, generate a satisfying assignment in its bit-vector language and output a string solution; otherwise, report unsatisfiable. 

We discuss the prominent feature and illustrate its language input by example. Hampi input enables the encoding of string constraint generated from the typical testing and security applications. The language supports the declaration of fixed-size variables and constraints, regular language operations, membership predicates, and the declaration of context free and regular languages, temporaries and constraints.

Var is the string variable declared of the size specified. If all the constraints of the Hampi are satisfiable, var will be afforded value meets all the constraints. Sometimes, the application requires the constraint solver to consider all the string up to a fixed size. This end could be achieved by one of the following two ways: (1) repeatedly applying Hampi for different fixed size up to the given maximum size; (2) adjusting the constraints to allow "padding" of the variable. 

Hampi allows the standard notation Extended Backus-Naur Form(EBNF) to specify context free grammar in input. Terminals are enclosed in double quotes(e.g., "SELECT"), and productions are seperated by vertical bar symble (|). Grammars may contain special symbols for repetition (+ and *) and character ranges(e.g.,[a-z]).

Reg is the declaration of regular language. Regular languages are defined as following four regular expressions:(i) a singleton set with a string constant; (ii) a concatenation or union of regular languages; (iii) a repetition of a regular language; (iv) a fixed sizing of a context free language. Every regular language can be defined by the first three of these operations.  

Vals are temporary variables that act as shortcuts for expressing constraints on expressions that are concatenations of the string varibles and constants.

Assert is the key word that used by Hampi to express the membership of strings in regular languages.
\section{Introduction} 
To achieve automatic test (data) generation from source code, there are currently two well established frameworks: constraint-based testing~\cite{constraint,inka,dart,cute,onthefly}  (CBT) and search-based testing~\cite{iterative,una,empirical,auto,procedure} (SBT). CBT approach focuses on translating part of a program into a logical formula whose solutions are relevant to test data, while SBT approach is based on exploring the input space of the program using optimisation-like methods to guide the search toward relevant test data. In \cite{empirical}, Harman et al. show that SBT can be local or global. Similarly, CBT also can be global, translating the whole program in a formula \cite{constraint,inka}, or local (path-based) \cite{dart,cute,onthefly}, focusing on a single path. In this report, we focus on path-based CBT, referred as path-based testing. Obviously such a local analysis is not sufficient to prove correctness of the whole system, however it is sufficient to derive a test data exercising the given path at runtime. Then, iterating the process on many different paths allows to automatically build test suites achieving a given structural coverage objective, e.g. branch coverage.

Symbolic execution~\cite{symbolic} is a way to track programs symbolicly rather than executing them with actual input value. Concolic path-based testing tools have literally blossomed up recently \cite{extenjpf,structural,mixed,exe,fuzz,pex} with the impressive progress in constraint solvers. Concolic path-based testing tools combine both concrete and symbolic execution (referred as concolic execution~\cite{dart,cute} or mixed execution~\cite{mixed}), which makes it possible to perform automatic path-based testing on large scale programs. By executing the program under test with concrete values while performing symbolic execution, symbolic constraints on the inputs can be collected from the predicates in branch statements, forming an expression, called path condition. To explore new paths, part of the constraints in the collected path conditions are negated to obtain new path conditions, which are sent to a constraint solver to compute test inputs for new paths. In theory, all feasible execution paths will be exercised eventually through the iterations of constraint collection and constraint solving in DSE. 

A program under test can be modeled as a control flow graph (CFG)~\cite{testbook}, whose nodes represent simple primitive statements (such as input, output, and assignment) and edges represent the flow of control. An execution path of the program is a path on CFG from the starting node, entry of the program, to the exit node, exit of the program. Thus, to explore all paths of the program under test, i.e. achieving 100\% path coverage, is to enumerate all paths between two nodes in a graph, which is well known as a NP-hard problem~\cite{graph}. To alleviate this path explosion problem and to reduce the computation complexity, different techniques has been proposed, such as pruning search space of symbolic execution~\cite{prune}, selective symbolic execution~\cite{selective} and fitness-guided path exploration~\cite{fitness}. In this report, we detail on the problem of test data generation and present three techniques to alleviate this path explosion problem and to reduce the computation complexity. We also discuss the Turing Award winners and early researchers who contributed to the field of research of test data generation.
 /**
 * JavaCC file
 */options{  JDK_VERSION = "1.5";}PARSER_BEGIN(Ice9Parser)public class Ice9Parser{  public static boolean isDebug = false;  public static void debug(String text)  {    if (isDebug)    {      System.out.println(text);    }  }  public static void debug()  {    System.out.println();  }  public static void main(String args []) throws ParseException, java.io.IOException  {    Ice9Parser parser = null;    try    {      parser = new Ice9Parser(new java.io.FileInputStream("test.dat"));      //      System.out.println("Reading from file " + "tests/test1.9");      parser.program();    }    catch (java.io.FileNotFoundException e)    {      System.out.println("Ice9 Parser:  File not found.");      return;    }    catch (TokenMgrError e)    {//      System.out.println(e.getMessage());
      String message = e.getMessage();
      
      int lineIndex = message.indexOf("line");
      int commaIndex = message.indexOf(",");
      int quoteIndex = message.indexOf("\"");
      String lineNbr = message.substring(lineIndex + 5, commaIndex);
      String t = message.substring(quoteIndex + 1,message.length() - 1);
      System.out.println("line " + lineNbr + ": illegal character (" + t + ")" );    }    catch (ParseException e)    {      Token t = e.currentToken;      int line = t.next.beginLine;      System.out.println("line " + line + ": syntax error near " + t.image);    }    catch (Exception e)    {      System.out.println(e.getMessage());    }    catch (Error e)    {      System.out.println(e.getMessage());    }  }}PARSER_END(Ice9Parser)SKIP :{  " "| "\r"| "\t"| "\n"| "\r\n"}SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >}TOKEN :{  < VAR : "var" >| < PROC : "proc" >| < END : "end" >| < RETURN : "return" >| < READ : "read" >| < WRITE : "write" >| < WRITES : "writes" >| < FORWARD : "forward" >| < TYPE : "type" >| < RARROW : "->" >}TOKEN : /*if*/{  < IF : "if" >| < ELSE : "else" >| < FI : "fi" >| < LR : "[]" >}TOKEN : /*do*/{  < DO : "do" >| < OD : "od" >}TOKEN : /*fa*/{  < FA : "fa" >| < AF : "af" >| < TO : "to" >}TOKEN : /*stm*/{  < BREAK : "break" >| < EXIT : "exit" >}TOKEN :{  < TRUE : "true" >| < FALSE : "false" >}/*
id	-> [A-Za-z][A-Za-z0-9_]*
int	-> [0-9]+
string  -> "[^"\n]*" 		# double-quoted string: any char but " and \n
	-> '[^'\n]*'            # single-quoted string: any char but ' and \n
*/TOKEN : /* Three complex tokens */{  < ID :    < LETTER >    (      < LETTER >    | < UNDERSCORE >    | < DIGIT >    )* >| < INT : (< DIGIT >)+ >| < STRING :    "\"" (~[ "\"", "\n" ])* "\""  | "'" (~[ "'", "\n" ])* "'" >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MOD : "%" >| < EQUAL : "=" >| < NOTEQUAL : "!=" >| < GREATERTHAN : ">" >| < LESSTHAN : "<" >| < NOTLESSTHAN : ">=" >| < NOTGREATERTHAN : "<=" >}TOKEN :{  < COLON : ":" >| < ASSIGN : ":=" >| < COMMA : "," >| < LBRACE : "[" >| < RBRACE : "]" >| < LPAREN : "(" >| < RPAREN : ")" >| < QUESTION : "?" >| < SEMICOLON : ";" >}/*
program	-> {var|type|forward|proc} stms
*/void program() :{}{  (    var()  | type()  | forward()  | proc()  )*  stms()  {    System.out.println("successfully!");  }  < EOF >}void tokenTest() :{  Token t;}{  t = < STRING >  {    debug("parsing string: " + t.image);  }  < EOF >}void typeid() :{  debug("in type id");}{  < ID >}String op() :{  debug("in op");  Token t;}{  (    t = < PLUS >  | t = < MINUS >  | t = < MULTIPLY >  | t = < DIVIDE >  | t = < MOD >  | t = < EQUAL >  | t = < NOTEQUAL >  | t = < GREATERTHAN >  | t = < LESSTHAN >  | t = < NOTGREATERTHAN >  | t = < NOTLESSTHAN >  )  {    return t.image;  }}/*idlist  -> id { ',' id}*/void idlist() :{  debug("in IdList");}{  < ID > (< COMMA > < ID >)*}/*
stms	-> stm { stm }		# there is at least one stm

stm	-> if | do | fa | 'break' ';' | 'exit' ';'
	-> 'return' ';'
	-> 'write' exp ';' | 'writes' exp ';'
	-> exp ';'		# any exp is valid
	-> ';'			# the "empty" statement
*/void stms() :{}{  (    stm()  )+}void stm() :{}{  otherstm()| ifstm()}void otherstm() :{}{  dostm()| fa()| < BREAK > < SEMICOLON >| < EXIT > < SEMICOLON >| < RETURN > < SEMICOLON >| < WRITE > exp() < SEMICOLON >| < WRITES > exp() < SEMICOLON >| exp() < SEMICOLON > // any exp is valid
| < SEMICOLON > // the "empty" statement
}/*
if	-> 'if' exp '->' stms { '[]' exp '->' stms } 'fi'
	-> 'if' exp '->' stms { '[]' exp '->' stms } '[]' 'else' '->' stms 'fi'
*/void ifstm() :{  debug("if()");}{  < IF > exp() < RARROW > stms()  (    LOOKAHEAD(2)    < LR > exp() < RARROW > stms()  )*  [    LOOKAHEAD(2)    < LR > < ELSE > < RARROW > stms()  ]  < FI >}/*
do	-> 'do' exp '->' stms 'od'
*/void dostm() :{  debug("do()");}{  < DO > exp() < RARROW > stms() < OD >}/*
fa	-> 'fa' id ':=' exp 'to' exp '->' stms 'af'
*/void fa() :{  debug("fa()");}{  < FA > < ID > < ASSIGN > exp() < TO > exp() < RARROW > stms() < AF >}/*
proc	-> 'proc' id '(' declist ')'
		{type|var} {stm} 'end'
	-> 'proc' id '(' declist ')' ':' typeid 
		{type|var} {stm} 'end'
*/void proc() :{  debug("proc()");}{  < PROC > < ID > < LPAREN > declist() < RPAREN > [ < COLON > typeid() ]  (    type()  | var()  )*  (    stm()  )*  < END >}/*var	-> 'var' varlist
varlist  -> idlist ':' typeid { '[' int ']' } { ',' varlist}*/void varlist() :{  debug("varlist()");}{  idlist() < COLON > typeid() (< LBRACE > < INT > < RBRACE >)*  (    LOOKAHEAD(2)    < COMMA > varlist()  )*}void var() :{  debug("var()");}{  < VAR > varlist()}/*
forward -> 'forward' id '(' declist ')'
	-> 'forward' id '(' declist ')' ':' typeid
declist	-> idlist ':' typeid { ',' declist }
	->			# empty
*/void declist() :{  debug("declist()");}{  idlist() < COLON > typeid()  (    LOOKAHEAD(2)    < COMMA > declist()  )*|  {}}void forward() :{  debug("forward()");}{  < FORWARD > < ID > < LPAREN > declist() < RPAREN > [ ":" typeid() ]}/* type	-> 'type' id '=' typeid { '[' int ']' } */void type() :{  debug("type()");}{  < TYPE > < ID > < EQUAL > typeid() (< LBRACE > < INT > < RBRACE >)*}/*
lvalue	-> id | lvalue '[' exp ']'
*/void lvalue() :{  debug("lvalue()");}{  < ID >  (    < LBRACE > exp() < RBRACE >  )*}/*
exp	-> lvalue
	-> lvalue ':=' exp
	-> int				# integer literal
	-> 'true'			# boolean literal
	-> 'false'			# boolean literal
	-> string
	-> 'read'
	-> '-' exp
	-> '?' exp
	-> id '(' ')'			# procedure call
	-> id '(' exp { ',' exp } ')'	# procedure call
	-> exp '+' exp
	-> exp '-' exp
	-> exp '*' exp
	-> exp '/' exp
	-> exp '%' exp
	-> exp '=' exp
	-> exp '!=' exp
	-> exp '>' exp
	-> exp '<' exp
	-> exp '>=' exp
	-> exp '<=' exp
	-> '(' exp ')'
*/String exp() :{  debug("exp()");  Token k;}{  (    k = < INT >  | k = < TRUE >  | k = < FALSE >  | k = < STRING >  | k = < READ >  | k = < MINUS >  | k = < QUESTION >  | k = < LPAREN > exp() < RPAREN >  | k = < ID >    (      < LPAREN >      [        exp()        (          < COMMA > exp()        )*      ]      < RPAREN >    |      (        < LBRACE > exp() < RBRACE >      )*      [ < ASSIGN > exp() ]    )  )  (    LOOKAHEAD(2)    op() exp()  )*  {    debug(k.image);    return k.image;  }}void exp2() :{  debug("exp2()");}{  op() exp() exp2()|  {}}

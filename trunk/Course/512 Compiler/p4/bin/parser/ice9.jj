/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ice9.jj */
/*@egen*/ /**
 * JavaCC file
 */options{  JDK_VERSION = "1.5";  STATIC = true;                                }PARSER_BEGIN(Ice9Parser)package parser;import type.*;import table.*;import java.util.*;import java.io.*;import parser.visitor.*;public class Ice9Parser/*@bgen(jjtree)*/implements Ice9ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTIce9ParserState jjtree = new JJTIce9ParserState();

/*@egen*/  public static boolean isDebug = false;  public static boolean isDebug2 = false;  public static boolean debugTable = false;  public static SymbolTable globalTable = new SymbolTable();  public static SymbolTable currentTable = new SymbolTable();  public static Stack < String > loopStack = new Stack < String > ();  public static void debug(String text)  {    if (isDebug)    {      System.out.println(text);    }  }  public static void debugTable(String text)  {    if (debugTable)    {      System.out.println(text);    }  }  public static void debug2(String text)  {    if (isDebug2)    {      System.out.println(text);    }  }  public static void debug()  {    System.out.println();  }  public static void main(String args []) throws ParseException, java.io.IOException  {    Ice9Parser parser = null;    try    {      //      parser = new Ice9Parser(new java.io.FileInputStream("test-suite/tests/test245.9"));      parser = new Ice9Parser(new java.io.FileInputStream("test.dat"));      //      parser = new Ice9Parser(System.in);      //      System.out.println("Reading from file " + "dice/test1.9");
      ASTprogram n = parser.program();      n.dump("");      //      CodeGenerationVisitor visitor = new CodeGenerationVisitor();
      CodeGenerationVisitor visitor = new CodeGenerationVisitor();      n.jjtAccept(visitor, null);      System.out.println("successfully");    }    //    catch (java.io.FileNotFoundException e)    //    {    //      System.out.println("Ice9 Parser:  File not found.");    //      return;    //    }    catch (TokenMgrError e)    {      //      System.out.println(e.getMessage());
      String message = e.getMessage();      int lineIndex = message.indexOf("line");      int commaIndex = message.indexOf(",");      int quoteIndex = message.indexOf("\"");      int lineNbr = Integer.parseInt(message.substring(lineIndex + 5, commaIndex));      String t = message.substring(quoteIndex + 1, message.length() - 1);      System.out.println("line " + lineNbr + ": illegal character (" + t + ")");    }    catch (TypeException e)    {      System.out.println(e.prettyMessage());      System.out.println(e.getMessage());      //      System.out.println(e.getMessage());
    }    catch (SymbolTableException e)    {      System.out.println(e.prettyMessage());      System.out.println(e.getMessage());    }    catch (ParseException e)    {      Token t = e.currentToken;      int line = t.next.beginLine;      String value = t.image;      if (value == null)      {        value = "";      }      System.out.println("line " + line + ": syntax error near " + value);      System.out.println(e.getMessage());    }    catch (Exception e)    {      e.printStackTrace();    }    catch (Error e)    {      e.printStackTrace();    }    finally    {      debugTable("debug table: " + currentTable.toString());    }    FileWriter fstream = new FileWriter("test.out");    BufferedWriter out = new BufferedWriter(fstream);    for (int i = 1; i <= 0; i++)    {      try      {        System.out.println("parsing " + "test-suite/tests/test" + i + ".9");        parser.ReInit(new java.io.FileInputStream("test-suite/tests/test" + i + ".9"));        parser.program();        System.out.println("successfully");        out.write("test " + i + " successful!\n");      }      catch (TokenMgrError e)      {        //      System.out.println(e.getMessage());
        String message = e.getMessage();        int lineIndex = message.indexOf("line");        int commaIndex = message.indexOf(",");        int quoteIndex = message.indexOf("\"");        int lineNbr = Integer.parseInt(message.substring(lineIndex + 5, commaIndex));        String t = message.substring(quoteIndex + 1, message.length() - 1);        System.out.println("line " + lineNbr + ": illegal character (" + t + ")");      }      catch (TypeException e)      {        System.out.println(e.prettyMessage());        System.out.println(e.getMessage());        //      System.out.println(e.getMessage());
      }      catch (SymbolTableException e)      {        System.out.println(e.prettyMessage());        System.out.println(e.getMessage());      }      catch (ParseException e)      {        Token t = e.currentToken;        int line = t.next.beginLine;        String value = t.image;        if (value == null)        {          value = "";        }        System.out.println("line " + line + ": syntax error near " + value);        System.out.println(e.getMessage());      }      catch (Exception e)      {        e.printStackTrace();      }      catch (Error e)      {        e.printStackTrace();      }    }    try    {      out.close();    }    catch (Exception e)    {}  }}PARSER_END(Ice9Parser)SKIP :{  " "| "\r"| "\t"| "\n"| "\r\n"}SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}TOKEN :{  < VAR : "var" >| < PROC : "proc" >| < END : "end" >| < RETURN : "return" >| < READ : "read" >| < WRITE : "write" >| < WRITES : "writes" >| < FORWARD : "forward" >| < TYPE : "type" >| < RARROW : "->" >}TOKEN : /*if*/{  < IF : "if" >| < ELSE : "else" >| < FI : "fi" >| < LR : "[]" >}TOKEN : /*do*/{  < DO : "do" >| < OD : "od" >}TOKEN : /*fa*/{  < FA : "fa" >| < AF : "af" >| < TO : "to" >}TOKEN : /*stm*/{  < BREAK : "break" >| < EXIT : "exit" >}TOKEN :{  < TRUE : "true" >| < FALSE : "false" >}/*
id	-> [A-Za-z][A-Za-z0-9_]*
int	-> [0-9]+
string  -> "[^"\n]*" 		# double-quoted string: any char but " and \n
	-> '[^'\n]*'            # single-quoted string: any char but ' and \n
*/TOKEN : /* Three complex tokens */{  < ID :    < LETTER >    (      < LETTER >    | < UNDERSCORE >    | < DIGIT >    )* >| < INT : (< DIGIT >)+ >| < STRING :    "\"" (~[ "\"", "\n" ])* "\""  | "'" (~[ "'", "\n" ])* "'" >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MOD : "%" >| < EQUAL : "=" >| < NOTEQUAL : "!=" >| < GREATERTHAN : ">" >| < LESSTHAN : "<" >| < NOTLESSTHAN : ">=" >| < NOTGREATERTHAN : "<=" >}TOKEN :{  < COLON : ":" >| < ASSIGN : ":=" >| < COMMA : "," >| < LBRACE : "[" >| < RBRACE : "]" >| < LPAREN : "(" >| < RPAREN : ")" >| < QUESTION : "?" >| < SEMICOLON : ";" >}/*
program	-> {var|type|forward|proc} stms
*/ASTprogram program() :{/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  globalTable = new SymbolTable();  globalTable.isGlobal = true;  globalTable.parent = SymbolTable.buildInTable();  currentTable = globalTable;  Token end;  jjtn000.jjtSetValue(TypeRecord.voidType);}{/*@bgen(jjtree) program */
  try {
/*@egen*/  (    var()  | type()  | forward()  | proc()  )*  stms()  { //System.out.println("successfully!");
  }  end = < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    List < String > forwardWOProcs = currentTable.getForwardsWithoutProc();    if (forwardWOProcs.size() > 0)    {      throw new TypeException(TypeError.FORWARD_WITHOUT_PROC, "These forward: " + forwardWOProcs + " has not proc definition.", end);    }    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void tokenTest() :{/*@bgen(jjtree) tokenTest */
  ASTtokenTest jjtn000 = new ASTtokenTest(JJTTOKENTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) tokenTest */
  try {
/*@egen*/  t = < STRING >  {    debug("parsing string: " + t.image);  }  < EOF >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String typeid() :{/*@bgen(jjtree) typeid */
  ASTtypeid jjtn000 = new ASTtypeid(JJTTYPEID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("in type id");  Token id;}{/*@bgen(jjtree) typeid */
  try {
/*@egen*/  id = < ID >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    TypeRecord type = currentTable.lookupType(id, id.image);    jjtn000.jjtSetValue(type);    return id.image;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String op() :{/*@bgen(jjtree) op */
  ASTop jjtn000 = new ASTop(JJTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("in op");  Token t;}{/*@bgen(jjtree) op */
  try {
/*@egen*/  (    t = < PLUS >  | t = < MINUS >  | t = < MULTIPLY >  | t = < DIVIDE >  | t = < MOD >  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return t.image;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*idlist  -> id { ',' id}*/List < Token > idlist() :{/*@bgen(jjtree) idlist */
  ASTidlist jjtn000 = new ASTidlist(JJTIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("in IdList");  List < Token > tokens = new ArrayList < Token > ();  Token current;}{/*@bgen(jjtree) idlist */
  try {
/*@egen*/  current = < ID >  {    tokens.add(current);  }  (    < COMMA > current = < ID >    {      tokens.add(current);    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return tokens;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
stms	-> stm { stm }		# there is at least one stm

stm	-> if | do | fa | 'break' ';' | 'exit' ';'
	-> 'return' ';'
	-> 'write' exp ';' | 'writes' exp ';'
	-> exp ';'		# any exp is valid
	-> ';'			# the "empty" statement
*/void stms() :{/*@bgen(jjtree) stms */
  ASTstms jjtn000 = new ASTstms(JJTSTMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.jjtSetValue(TypeRecord.voidType);}{/*@bgen(jjtree) stms */
  try {
/*@egen*/  (    stm()  )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void stm() :{/*@bgen(jjtree) stm */
  ASTstm jjtn000 = new ASTstm(JJTSTM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.jjtSetValue(TypeRecord.voidType);}{/*@bgen(jjtree) stm */
  try {
/*@egen*/  otherstm()| ifstm()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void otherstm() :{/*@bgen(jjtree) otherstm */
  ASTotherstm jjtn000 = new ASTotherstm(JJTOTHERSTM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("in other");  TypeRecord returnType;  jjtn000.jjtSetValue(TypeRecord.voidType);}{/*@bgen(jjtree) otherstm */
  try {
/*@egen*/  dostm()| fa()| break_stm()| exit_stm()| return_stm()| write_stm()| exp() < SEMICOLON > // any exp is valid
| < SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ // the "empty" statement
}TypeRecord return_stm() :{/*@bgen(jjtree) return_stm */
  ASTreturn_stm jjtn000 = new ASTreturn_stm(JJTRETURN_STM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) return_stm */
  try {
/*@egen*/  t = < RETURN > < SEMICOLON >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(TypeRecord.voidType);    return TypeRecord.voidType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord exit_stm() :{/*@bgen(jjtree) exit_stm */
  ASTexit_stm jjtn000 = new ASTexit_stm(JJTEXIT_STM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) exit_stm */
  try {
/*@egen*/  t = < EXIT > < SEMICOLON >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(TypeRecord.voidType);    return TypeRecord.voidType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord break_stm() :{/*@bgen(jjtree) break_stm */
  ASTbreak_stm jjtn000 = new ASTbreak_stm(JJTBREAK_STM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) break_stm */
  try {
/*@egen*/  t = < BREAK >  {    if (loopStack.empty())    {      throw new TypeException(TypeError.WRONG_USAGE, "break is not allowed in the scopes without loop", t);    }  }  < SEMICOLON >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(TypeRecord.voidType);    return TypeRecord.voidType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void write_stm() :{/*@bgen(jjtree) write_stm */
  ASTwrite_stm jjtn000 = new ASTwrite_stm(JJTWRITE_STM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  TypeRecord returnType;  Token write;}{/*@bgen(jjtree) write_stm */
  try {
/*@egen*/  (    write = < WRITE >  | write = < WRITES >  )  returnType = noAssignExp()  {    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", write);    }    if (returnType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "bool type not allowed", write);    }  }  < SEMICOLON >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setFirstToken(write);    jjtn000.jjtSetValue(TypeRecord.voidType);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
if	-> 'if' exp '->' stms { '[]' exp '->' stms } 'fi'
	-> 'if' exp '->' stms { '[]' exp '->' stms } '[]' 'else' '->' stms 'fi'
*/void ifstm() :{/*@bgen(jjtree) ifstm */
  ASTifstm jjtn000 = new ASTifstm(JJTIFSTM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("if()");  TypeRecord conditionType;  Token iftoken;  SymbolTable newScope;}{/*@bgen(jjtree) ifstm */
  try {
/*@egen*/  iftoken = < IF > conditionType = noAssignExp()  {    debug2("type:" + conditionType);    if (!conditionType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "if condition must be bool", iftoken);    }  }  < RARROW >  {    newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;  }  stms()  {    currentTable = currentTable.parent;  }  (    LOOKAHEAD(2)    < LR > conditionType = noAssignExp()    {      if (!conditionType.equals(TypeRecord.boolType))      {        throw new TypeException(TypeError.WRONG_TYPE, "else if condition must be bool", iftoken);      }    }    < RARROW >    {      newScope = new SymbolTable();      newScope.parent = currentTable;      currentTable = newScope;    }    stms()    {      currentTable = currentTable.parent;    }  )*  [    LOOKAHEAD(2)    < LR > < ELSE > < RARROW >    {      newScope = new SymbolTable();      newScope.parent = currentTable;      currentTable = newScope;    }    stms()    {      currentTable = currentTable.parent;    }  ]  < FI >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
do	-> 'do' exp '->' stms 'od'
*/void dostm() :{/*@bgen(jjtree) dostm */
  ASTdostm jjtn000 = new ASTdostm(JJTDOSTM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("do()");  TypeRecord conditionType;  Token dotoken;}{/*@bgen(jjtree) dostm */
  try {
/*@egen*/  dotoken = < DO > conditionType = noAssignExp()  {    if (!conditionType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "do condition must be bool", dotoken);    }  }  < RARROW >  {    SymbolTable newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;    loopStack.push("do");  }  stms()  {    loopStack.pop();    currentTable = currentTable.parent;  }  < OD >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
fa	-> 'fa' id ':=' exp 'to' exp '->' stms 'af'
*/void fa() :{/*@bgen(jjtree) fa */
  ASTfa jjtn000 = new ASTfa(JJTFA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("fa()");  TypeRecord lowType;  TypeRecord highType;  Token dotoken;  Token id;}{/*@bgen(jjtree) fa */
  try {
/*@egen*/  < FA > id = < ID > < ASSIGN > lowType = noAssignExp()  {    if (!lowType.equals(TypeRecord.intType))    {      throw new TypeException(TypeError.WRONG_TYPE, "low condition must be int", id);    }  }  < TO > highType = noAssignExp()  {    if (!highType.equals(TypeRecord.intType))    {      throw new TypeException(TypeError.WRONG_TYPE, "high condition must be int", id);    }  }  < RARROW >  {    SymbolTable newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;    currentTable.insertId(id, new TypeRecord(BasicType.INT, true));    loopStack.push("fa");  }  stms()  {    loopStack.pop();    currentTable = currentTable.parent;  }  < AF >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
proc	-> 'proc' id '(' declist ')'
		{type|var} {stm} 'end'
	-> 'proc' id '(' declist ')' ':' typeid 
		{type|var} {stm} 'end'
*/void proc() :{/*@bgen(jjtree) proc */
  ASTproc jjtn000 = new ASTproc(JJTPROC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("proc()");  Token id;  List < ParaType > paras;  TypeRecord returnType = null;  ProcType forwardType = null;  Token end;}{/*@bgen(jjtree) proc */
  try {
/*@egen*/  < PROC > id = < ID >  {    if (currentTable.existsProc(id))    {      throw new SymbolTableException(LookupError.PROC_ALREADY_DEFINED, id, "proc has been defined in current table.");    }    if (currentTable.existsForward(id))    {      forwardType = currentTable.lookupForward(id);    }  }  < LPAREN > paras = declist() < RPAREN >  [    < COLON > typeid()    {      returnType = (TypeRecord) ((SimpleNode) (jjtree.peekNode())).jjtGetValue();    }  ]  {    if (forwardType != null)    {      if (returnType == null)      {        returnType = TypeRecord.voidType;      }      if (!returnType.equals(forwardType.returnType))      {        throw new TypeException(TypeError.WRONG_TYPE, "proc " + id.image + " return type of proc is different from forward", id);      }      List < ParaType > forwardParas = forwardType.paraTypes;      if (paras.size() != forwardParas.size())      {        throw new TypeException(TypeError.WRONG_TYPE, "proc " + id.image + " size of parameters of proc is different from forward", id);      }      for (int i = 0; i < paras.size(); i++)      {        if (!paras.get(i).type.equals(forwardParas.get(i).type))        {          throw new TypeException(TypeError.WRONG_TYPE, "proc " + id.image + " " + i + "th para is different from forward", id);        }      }    }    ProcType newproc = new ProcType(returnType, paras);    currentTable.insertProc(id, newproc);    jjtn000.jjtSetValue(TypeRecord.voidType);    SymbolTable newScope = new SymbolTable();    newScope.parent = currentTable;    currentTable = newScope;    if (returnType != null)    {      currentTable.insertId(id, returnType);    }    for (ParaType para : paras)    {      currentTable.insertId(para.id, para.type);    }  }  (    type()  | var()  )*  (    stm()  )*  {    currentTable = currentTable.parent;  }  end = < END >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*var	-> 'var' varlist
varlist  -> idlist ':' typeid { '[' int ']' } { ',' varlist}*/void varlist() :{/*@bgen(jjtree) varlist */
  ASTvarlist jjtn000 = new ASTvarlist(JJTVARLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("varlist()");  List < Token > tokens;  TypeRecord type;  Token size;  String typeid;  TypeRecord currentType;  SimpleNode typeNode;  boolean isFirst = true;  TypeRecord baseType;  TypeRecord returnType;}{/*@bgen(jjtree) varlist */
  try {
/*@egen*/  tokens = idlist() < COLON > typeid = typeid()  {    typeNode = (SimpleNode) jjtree.peekNode();    currentType = (TypeRecord) typeNode.jjtGetValue();    baseType = currentType;    returnType = currentType;  }  (    < LBRACE > size = < INT > < RBRACE >    {      if (Integer.parseInt(size.image) == 0)      {        throw new TypeException(TypeError.WRONG_VALUE, "array size cannot be 0", size);      }      int intsize = Integer.parseInt(size.image);      if (isFirst)      {        currentType = TypeRecord.arrayType(intsize, currentType);        isFirst = false;        returnType = currentType;      }      else      {        TypeRecord newArray = TypeRecord.arrayType(intsize, baseType);        currentType.underType = newArray;        currentType = newArray;      }    }  )*  {    currentTable.insertIds(tokens, returnType);  }  (    LOOKAHEAD(2)    < COMMA > varlist()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void var() :{/*@bgen(jjtree) var */
  ASTvar jjtn000 = new ASTvar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("var()");}{/*@bgen(jjtree) var */
  try {
/*@egen*/  < VAR > varlist()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
forward -> 'forward' id '(' declist ')'
	-> 'forward' id '(' declist ')' ':' typeid
declist	-> idlist ':' typeid { ',' declist }
	->			# empty
*/List < ParaType > declist() :{/*@bgen(jjtree) declist */
  ASTdeclist jjtn000 = new ASTdeclist(JJTDECLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("declist()");  List < Token > ids = new ArrayList < Token > ();  List < ParaType > paraTypes = new ArrayList < ParaType > ();  SimpleNode typeNode;  TypeRecord type;  List < ParaType > newList;  HashSet < String > paraNames = new HashSet < String > ();}{/*@bgen(jjtree) declist */
  try {
/*@egen*/  (    ids = idlist() < COLON > typeid()    {      typeNode = (SimpleNode) jjtree.peekNode();      type = (TypeRecord) typeNode.jjtGetValue();      for (Token id : ids)      {        if (paraNames.contains(id.image))        {          throw new TypeException(TypeError.PARA_NAME_ALREADY_DEFINED, "parameter name in proc declaration cannot be same", id);        }        paraNames.add(id.image);        paraTypes.add(new ParaType(type, id));      }    }    (      LOOKAHEAD(2)      < COMMA > newList = declist()      {        for (ParaType paratype : newList)        {          paraTypes.add(paratype);        }      }    )*  |    {}  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return paraTypes;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void forward() :{/*@bgen(jjtree) forward */
  ASTforward jjtn000 = new ASTforward(JJTFORWARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("forward()");  Token id;  List < ParaType > paras = null;  TypeRecord returnType = null;}{/*@bgen(jjtree) forward */
  try {
/*@egen*/  < FORWARD > id = < ID > < LPAREN > paras = declist() < RPAREN >  [    ":" typeid()    {      returnType = (TypeRecord) ((SimpleNode) (jjtree.peekNode())).jjtGetValue();    }  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (returnType == null)    {      returnType = TypeRecord.voidType;    }    ProcType newforward = new ProcType(returnType, paras);    currentTable.insertForward(id, newforward);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/* type	-> 'type' id '=' typeid { '[' int ']' } */void type() :{/*@bgen(jjtree) type */
  ASTtype jjtn000 = new ASTtype(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("type()");  Token id;  String typeId;  TypeRecord baseType;  Token size;  TypeRecord returnType;  TypeRecord currentType;  boolean isFirst = true;}{/*@bgen(jjtree) type */
  try {
/*@egen*/  < TYPE > id = < ID > < EQUAL > typeId = typeid()  {    baseType = (TypeRecord) (((SimpleNode) (jjtree.peekNode())).jjtGetValue());    currentType = baseType;    returnType = currentType;  }  (    < LBRACE > size = < INT > < RBRACE >    {      int intsize = Integer.parseInt(size.image);      if (intsize == 0)      {        throw new TypeException(TypeError.WRONG_VALUE, "array size cannot be 0", size);      }      if (isFirst)      {        currentType = TypeRecord.arrayType(intsize, baseType);        returnType = currentType;        isFirst = false;      }      else      {        TypeRecord newArray = TypeRecord.arrayType(intsize, baseType);        currentType.underType = newArray;        currentType = newArray;      }    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    currentTable.insertType(id, returnType);    jjtn000.jjtSetValue(returnType);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
lvalue	-> id | lvalue '[' exp ']'
*/TypeRecord lvalue() :{/*@bgen(jjtree) lvalue */
  ASTlvalue jjtn000 = new ASTlvalue(JJTLVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("lvalue()");  Token id;  TypeRecord type;  Token lbrace;  TypeRecord indexType;}{/*@bgen(jjtree) lvalue */
  try {
/*@egen*/  id = < ID >  {    type = currentTable.lookupId(id);  }  (    lbrace = < LBRACE > indexType = noAssignExp() < RBRACE >    {      if (!TypeRecord.isArray(type))      {        throw new TypeException(TypeError.WRONG_TYPE, "type must be array for indexing", lbrace);      }      if (!indexType.equals(TypeRecord.intType))      {        throw new TypeException(TypeError.WRONG_TYPE, "array index must be integer", lbrace);      }      type = type.underType;    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    debugTable("id:" + id + " type: " + type);    jjtn000.jjtSetValue(type);    return type;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/*
exp	-> lvalue
	-> lvalue ':=' exp
	-> int				# integer literal
	-> 'true'			# boolean literal
	-> 'false'			# boolean literal
	-> string
	-> 'read'
	-> '-' exp
	-> '?' exp
	-> id '(' ')'			# procedure call
	-> id '(' exp { ',' exp } ')'	# procedure call
	-> exp '+' exp
	-> exp '-' exp
	-> exp '*' exp
	-> exp '/' exp
	-> exp '%' exp
	-> exp '=' exp
	-> exp '!=' exp
	-> exp '>' exp
	-> exp '<' exp
	-> exp '>=' exp
	-> exp '<=' exp
	-> '(' exp ')'
*/Token compareOp() :{/*@bgen(jjtree) compareOp */
  ASTcompareOp jjtn000 = new ASTcompareOp(JJTCOMPAREOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) compareOp */
  try {
/*@egen*/  (    t = < EQUAL >  | t = < NOTEQUAL >  | t = < GREATERTHAN >  | t = < LESSTHAN >  | t = < NOTGREATERTHAN >  | t = < NOTLESSTHAN >  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {
    jjtn000.setFirstToken(t);    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Additive() :{/*@bgen(jjtree) Additive */
  ASTAdditive jjtn000 = new ASTAdditive(JJTADDITIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Object returnType;  Token t;}{/*@bgen(jjtree) Additive */
  try {
/*@egen*/  Times()  {    returnType = ((SimpleNode) (jjtree.peekNode())).jjtGetValue();  }  (    LOOKAHEAD(2)    (      t = < PLUS >    | t = < MINUS >    )/*@bgen(jjtree) #plusMinus( 2) */
    {
      ASTplusMinus jjtn001 = new ASTplusMinus(JJTPLUSMINUS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    Times()/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/                {    SimpleNode plusMinusNode = (SimpleNode) jjtree.peekNode();    plusMinusNode.setFirstToken(t);    SimpleNode firstChild = ((SimpleNode) (plusMinusNode.jjtGetChild(0)));    SimpleNode secondChild = ((SimpleNode) (plusMinusNode.jjtGetChild(1)));    TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();    TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();    if (firstType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if (!firstType.equals(secondType))    {      throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in times", t);    }    if (firstType.equals(TypeRecord.boolType) && (t.image.equals("-") || t.image.equals("%")))    {      throw new TypeException(TypeError.WRONG_TYPE, "cannot use -/% for two bools", t);    }    returnType = firstType;    plusMinusNode.jjtSetValue(returnType);  })*/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/{  jjtn000.jjtSetValue(returnType);  debug2("in additive: ");  debug2("this: " + jjtn000.jjtGetValue());}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Times() :{/*@bgen(jjtree) Times */
  ASTTimes jjtn000 = new ASTTimes(JJTTIMES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Object returnType;  Token t;}{/*@bgen(jjtree) Times */
  try {
/*@egen*/  PrefixExp()  {    returnType = ((SimpleNode) (jjtree.peekNode())).jjtGetValue();  }  (    LOOKAHEAD(2)    (      t = < MULTIPLY >    | t = < DIVIDE >
    | t = < MOD >    )/*@bgen(jjtree) #timeDivide( 2) */
    {
      ASTtimeDivide jjtn001 = new ASTtimeDivide(JJTTIMEDIVIDE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    PrefixExp()/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/                 {    SimpleNode timesNode = (SimpleNode) jjtree.peekNode();    timesNode.setFirstToken(t);    SimpleNode firstChild = ((SimpleNode) (timesNode.jjtGetChild(0)));    SimpleNode secondChild = ((SimpleNode) (timesNode.jjtGetChild(1)));    TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();    TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();    if (firstType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if (!firstType.equals(secondType))    {      throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in times", t);    }    if (firstType.equals(TypeRecord.boolType) && t.image.equals("/"))    {      throw new TypeException(TypeError.WRONG_TYPE, "cannot use / for two bools", t);    }    returnType = firstType;    timesNode.jjtSetValue(returnType);  })*/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/{  jjtn000.jjtSetValue(returnType);  debug2("in times: ");  debug2("this: " + jjtn000.jjtGetValue());}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord PrefixExp() :{/*@bgen(jjtree) PrefixExp */
  ASTPrefixExp jjtn000 = new ASTPrefixExp(JJTPREFIXEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  TypeRecord returnType;}{/*@bgen(jjtree) PrefixExp */
  try {
/*@egen*/  (    returnType = Unary()  | returnType = PrimaryExp()  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(returnType);    return returnType;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord Unary() :{/*@bgen(jjtree) Unary */
  ASTUnary jjtn000 = new ASTUnary(JJTUNARY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Object returnType;  Token t = null;  Token t2 = null;}{/*@bgen(jjtree) Unary */
  try {
/*@egen*/  (    t = < MINUS > [ t2 = < QUESTION > ] returnType = PrimaryExp()  | t = < QUESTION > [ t2 = < MINUS > ] returnType = PrimaryExp()  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (returnType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if ((t.image.equals("?") || (t2 != null && t2.image.equals("?"))) && !returnType.equals(TypeRecord.boolType))    {      throw new TypeException(TypeError.WRONG_TYPE, "unary ? only allows bool", t);    }    if (t.image.equals("-") && (!returnType.equals(TypeRecord.boolType) && !returnType.equals(TypeRecord.intType)))    {      throw new TypeException(TypeError.WRONG_TYPE, "unary - only allows bool and int", t);    }    if ((t.image.equals("?") || (t2 != null && t2.image.equals("?"))) && returnType.equals(TypeRecord.boolType))    {      returnType = TypeRecord.intType;    }    jjtn000.jjtSetValue(returnType);
    jjtn000.addToken(t);
    jjtn000.addToken(t2);    debug2("in unary: ");    debug2("this: " + jjtn000.jjtGetValue());    return (TypeRecord) returnType;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord PrimaryExp() :{/*@bgen(jjtree) PrimaryExp */
  ASTPrimaryExp jjtn000 = new ASTPrimaryExp(JJTPRIMARYEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  TypeRecord returnType;  SimpleNode child;  Token t = null;}{/*@bgen(jjtree) PrimaryExp */
  try {
/*@egen*/  (    returnType = intTerm()  | returnType = boolTerm()  | returnType = stringTerm()  | returnType = readTerm()  | < LPAREN > returnType = noAssignExp() < RPAREN >    {      jjtn000.jjtSetValue(returnType);    }  | LOOKAHEAD(procedureCall())    returnType = procedureCall()    {      jjtn000.jjtSetValue(returnType);    }  | returnType = lvalue()    {      jjtn000.jjtSetValue(returnType);    }  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(returnType);    jjtn000.setFirstToken(t);    return returnType;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord intTerm() :{/*@bgen(jjtree) intTerm */
  ASTintTerm jjtn000 = new ASTintTerm(JJTINTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) intTerm */
  try {
/*@egen*/  t = < INT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.jjtSetValue(TypeRecord.intType);    debug2("found int types");    debug2("this: " + jjtn000.jjtGetValue());    jjtn000.setFirstToken(t);    return TypeRecord.intType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord boolTerm() :{/*@bgen(jjtree) boolTerm */
  ASTboolTerm jjtn000 = new ASTboolTerm(JJTBOOLTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) boolTerm */
  try {
/*@egen*/  (    t = < TRUE >    {      jjtn000.jjtSetValue(TypeRecord.boolType);    }  | t = < FALSE >    {      jjtn000.jjtSetValue(TypeRecord.boolType);    }  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setFirstToken(t);    return TypeRecord.boolType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord readTerm() :{/*@bgen(jjtree) readTerm */
  ASTreadTerm jjtn000 = new ASTreadTerm(JJTREADTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) readTerm */
  try {
/*@egen*/  t = < READ >  {    jjtn000.jjtSetValue(TypeRecord.intType);  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setFirstToken(t);    return TypeRecord.intType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord stringTerm() :{/*@bgen(jjtree) stringTerm */
  ASTstringTerm jjtn000 = new ASTstringTerm(JJTSTRINGTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) stringTerm */
  try {
/*@egen*/  t = < STRING >  {    jjtn000.jjtSetValue(TypeRecord.strType);  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setFirstToken(t);    return TypeRecord.strType;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord procedureCall() :{/*@bgen(jjtree) procedureCall */
  ASTprocedureCall jjtn000 = new ASTprocedureCall(JJTPROCEDURECALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token id;  ProcType proc;  List < TypeRecord > types = new ArrayList < TypeRecord > ();  TypeRecord paraType;  Token rparen;}{/*@bgen(jjtree) procedureCall */
  try {
/*@egen*/  id = < ID >  {    proc = currentTable.lookupProc(id);  }  < LPAREN >  [    paraType = noAssignExp()    {      types.add(paraType);    }    (      < COMMA > paraType = noAssignExp()      {        types.add(paraType);      }    )*  ]  rparen = < RPAREN >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (types.size() != proc.paraTypes.size())    {      throw new TypeException(TypeError.WRONG_TYPE, "the size of parameters " + types.size() + " is not equal to the size of proc " + id.image + " parameters: " + proc.paraTypes.size(), rparen);    }    for (int i = 0; i < types.size(); i++)    {      TypeRecord procparaType = proc.paraTypes.get(i).type;      if (!types.get(i).equals(procparaType))      {        throw new TypeException(TypeError.WRONG_TYPE, i + "th parameter " + types.get(i) + " is not equal to " + i + "th parameter" + procparaType + " of proc " + id.image, rparen);      }    }    jjtn000.jjtSetValue(proc.returnType);    return proc.returnType;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void associateExp() :{/*@bgen(jjtree) associateExp */
  ASTassociateExp jjtn000 = new ASTassociateExp(JJTASSOCIATEEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) associateExp */
  try {
/*@egen*/  Additive()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    SimpleNode node = (SimpleNode) (jjtn000.jjtGetChild(0));    jjtn000.jjtSetValue(node.jjtGetValue());  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void exp() :{/*@bgen(jjtree) exp */
  ASTexp jjtn000 = new ASTexp(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  debug("exp()");  Token assign;}{/*@bgen(jjtree) exp */
  try {
/*@egen*/  (    LOOKAHEAD(lvalue() < ASSIGN > noAssignExp())    lvalue() assign = < ASSIGN > noAssignExp()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/    {      SimpleNode node = (SimpleNode) (jjtn000);      debug2("node in assign: " + node);      SimpleNode firstChild = ((SimpleNode) (node.jjtGetChild(0)));      SimpleNode secondChild = ((SimpleNode) (node.jjtGetChild(1)));      TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();      TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();      if (!firstType.equals(secondType))      {        throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in assign", assign);      }      if (TypeRecord.isArray(firstType))      {        throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", assign);      }      if (firstType.notAssignable)      {        throw new TypeException(TypeError.WRONG_TYPE, "this lvalue is not assignable", assign);      }      jjtn000.jjtSetValue(TypeRecord.voidType);    }  | noAssignExp()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/    {      SimpleNode node = (SimpleNode) (jjtn000.jjtGetChild(0));      jjtn000.jjtSetValue(node.jjtGetValue());    }  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}TypeRecord noAssignExp() :{/*@bgen(jjtree) noAssignExp */
  ASTnoAssignExp jjtn000 = new ASTnoAssignExp(JJTNOASSIGNEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Object returnType;  Token t;}{/*@bgen(jjtree) noAssignExp */
  try {
/*@egen*/  associateExp()  {    returnType = ((SimpleNode) (jjtree.peekNode())).jjtGetValue();  }  [    t = compareOp()/*@bgen(jjtree) #compares( 3) */
                    {
                      ASTcompares jjtn001 = new ASTcompares(JJTCOMPARES);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*/ associateExp()/*@bgen(jjtree)*/
                    } catch (Throwable jjte001) {
                      if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte001 instanceof RuntimeException) {
                        throw (RuntimeException)jjte001;
                      }
                      if (jjte001 instanceof ParseException) {
                        throw (ParseException)jjte001;
                      }
                      throw (Error)jjte001;
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  3);
                      }
                    }
/*@egen*/               {    SimpleNode comparesNode = (SimpleNode) jjtree.peekNode();    debug2("in noassign: ");    debug2("comparesNode: " + comparesNode);    debug2("comparesNode: " + comparesNode.jjtGetValue());    comparesNode.setFirstToken(t);    //      System.out.println("timesNode: " + );    SimpleNode firstChild = ((SimpleNode) (comparesNode.jjtGetChild(0)));    SimpleNode secondChild = ((SimpleNode) (comparesNode.jjtGetChild(2)));    TypeRecord firstType = (TypeRecord) firstChild.jjtGetValue();    TypeRecord secondType = (TypeRecord) secondChild.jjtGetValue();    if (firstType.equals(TypeRecord.strType))    {      throw new TypeException(TypeError.WRONG_TYPE, "string type not allowed", t);    }    if (TypeRecord.isArray(returnType))    {      throw new TypeException(TypeError.WRONG_TYPE, "array type not allowed", t);    }    if (!firstType.equals(secondType))    {      throw new TypeException(TypeError.TYPE_NOT_EQUAL, "type not equal in times", t);    }    if (firstType.equals(TypeRecord.boolType) && (!t.image.equals("=") && !t.image.equals("!=")))    {      throw new TypeException(TypeError.WRONG_TYPE, "cannot use >/</>=/<= for two bools", t);    }    returnType = TypeRecord.boolType;  }]/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/{  jjtn000.jjtSetValue(returnType);  return (TypeRecord) returnType;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
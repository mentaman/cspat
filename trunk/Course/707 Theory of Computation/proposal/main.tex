\documentclass[times, 10pt,onecolumn]{article} 
\usepackage{latex8}
\usepackage{times}
\usepackage{url}
%\usepackage{amsfonts, amsthm}

\title{Project Proposal}
\author{
Xusheng Xiao\\
\small{xxiao2@ncsu.edu}\\
\and
Xi Ge\\
\small{xge@ncsu.edu}\\
\and
Da Young Lee\\
\small{dlee10@ncsu.edu}
}
\date{January 27, 2010}


\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}

\begin{document}
\maketitle

\begin{flushleft}
\textbf{Project Topic:}\end{flushleft} Symbolic Execution in Software Engineering.\\

\begin{flushleft}
\textbf{Goal:}\end{flushleft}
Symbolic execution is a way to track programs symbolicly rather than executing them with actual input value. This technique is widely used in automatic test-case geneartion. In this project, we will provide a study of how finite state automaton, context-free grammer, and Computability and Computation Complexity are used in assisting symbolic execution to achieve higher testing performance and in resolving path explosion issues. 
\\

\begin{flushleft}
\textbf{Project Description}:\end{flushleft}
Instead of feeding normal input to programs, the symbolic execution proceeds with symbolic representing values\cite{symbolic}. In this project, we intend to explore the application of computation theory in this field and provide a detailed survey of the existing tools and techniques associating with symbolic execution. 

\begin{enumerate}
\item{\textbf{Finite State Automaton: assisting symbolic execution.} Existing dynamic symbolic execution (DSE) techniques can effectively generate test inputs for various programs to achieve high coverage. However, when dealing with the programs that use regular expression operations, the logic complexity makes it much more difficult for the DSE engine to achieve high branch coverage of the program under test within limited time and resources. With the help of finite state automaton, DSE is guided to achieve satisfactory branch coverage rate~\cite{reggae}.}

\item{\textbf{Context-Free Grammar: Generate Test Cases.} Symbolic execution for programs can be effectively reduced to a constraint-generation phase followed by a constraint-solving phase. Symbolic execution has trouble creating test cases that achieve high coverage for programs that expect structured inputs, such as those that require input strings from a context-free grammar. Kiezun et al.~\cite{hampi} propose Hampi to create grammar-based input constraints and then fed those into symbolic execution engine to generate test cases for programs. Given a set of constraints over a string variable, Hampi constraints express membership in regular and fixed-size context-free languages and output a string that satisfies all the constraints. Their evaluation results show that using Hampi can improve the effectiveness of symbolic execution. We plan to discuss the details in our project.}

\item{\textbf{Computability and Computation Complexity: Exploration Of Program and Model.} To generate test cases or test data respectively, a state-of-art technique known as dynamic symbolic execution (DSE)~\cite{dart,exe,cute}, is adopted by automatic test case generation tool to explore the feasible paths of the program under test and generate test cases to achieve high coverage. Dynamic symbolic execution (DSE) is a variation of static symbolic execution~\cite{static}. DSE performs a symbolic execution of the program by assigning symbolic variables to each program input and executes the program starting with arbitrary inputs. During the execution, DSE collects symbolic constraints on inputs obtained from predicates in branch statements along the execution. Then a constraint solver is used to compute new inputs in order to execute the program along different execution paths. In this way, all feasible execution paths will be exercised eventually through such iterations of input or path variations. A program under test can be modeled as a control flow graph (CFG)~\cite{testbook}, whose nodes represent simple primitive statements (such as input, output, and assignment) and edges represent the flow of control. An execution path of the program is a path on CFG from the starting node, entry of the program, to the exit node, exit of the program. Thus, to explore all paths of the program under test, i.e. achieving 100\% path coverage, is to enumerate all paths between two nodes in a graph, which is well known as a NP-hard problem. To alleviate this path explosion problem and to reduce the computation complexity, different techniques has been proposed, such as performing symbolic execution compositionally~\cite{compositional}, selective symbolic execution~\cite{selective} and fitness-guided path exploration~\cite{fitness}. In our project, we plan to discuss these techniques and provide example issues that can be solved using these techniques. Additionally, we plan to discuss the existing issues that are still not solved in the area of symbolic execution.}
\end{enumerate}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
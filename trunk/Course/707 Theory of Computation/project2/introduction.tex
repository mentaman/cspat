\section{Introduction} 
Symbolic execution~\cite{symbolic} is a way to track programs symbolicly rather than executing them with actual input value. Concolic path-based testing tools have literally blossomed up recently \cite{extenjpf,structural,mixed,exe,fuzzing,pex} with the impressive progress in constraint solvers. Concolic path-based testing tools combine both concrete and symbolic execution (referred as concolic execution~\cite{dart,cute} or mixed execution~\cite{mixed}), which makes it possible to perform automatic path-based testing on large scale programs. By executing the program under test with concrete values while performing symbolic execution, symbolic constraints on the inputs can be collected from the predicates in branch statements, forming an expression, called path condition. To explore new paths, part of the constraints in the collected path conditions are negated to obtain new path conditions, which are sent to a constraint solver to compute test inputs for new paths. In theory, all feasible execution paths will be exercised eventually through the iterations of constraint collection and constraint solving in DSE.

Whitebox fuzzing~\cite{fuzzing} executes the program under test with an initial, well-structured input, both concretely and symbolically. Along the execution, symbolic execution collects constraints on program inputs from the predicates in the conditional statements. The conjunction of these constraints of a execution path form an expression, called path condition. Satisfying the negation of each constraint in the path condition defines new inputs that exercise different control paths. Whitebox fuzzing repeats this process for the newly created inputs, with the goal of exercising many different control paths of the program under test and finding defects as fast as possible using various search heuristics. In practice, the search is usually incomplete because the number of feasible control paths grows exponentially with number of conditional statements in the program under test and because the precision of symbolic execution, constraint generation and solving is inherently limited. However, whitebox fuzzing has been shown to be very effective in finding new security vulnerabilities in several applications.

Hampi \cite{hampi} is designed and implemented as a constraint solver for string-manipulating programs. Hampi constraints express membership by regular language, fixed size context-free language. It may contain a fixed size string variable, context-free language definition, regular language definition and operations, and language-membership predicates. Given a set of string constraints over a string variable, Hampi outputs a string that satisfies all the constraints or reports that the constraints are unsatisfiable. Hampi is used as a component in testing, analysis, and verification applcations. Hampi can also be used to solve the intersection, containment, and equivalence problems for regular and fixed size context free languages.

CESE \cite{CESE} is an approach that targets at generating test inputs for programs accepting inputs, whose language can be described using context-free grammars. In particular, CESE is a hybrid approach that combines the advantages of two different approaches: specification-based enumerative test generation \cite{yagg} and dynamic symbolic execution \cite{system,symbolic,Test,counter,random}. CESE proposes symbolic grammar, which are in the form of context-free grammars. Symbolic grammar includes symbolic variables for terminals instead of actual concrete values, which are generally described using regular expressions. CESE automatically generates concrete values for symbolic variables in symbolic grammar by exploring the program under test using dynamic-symbolic-execution-based approaches. The primary advantage of symbolic grammars is that they reduce the state-space of possible values for inputs significantly.